import json
import strings
import os


const escaped_keywords = ['none', 'true', 'false', 'nil']

fn escape_keyword(keyword string) string {
  if keyword in escaped_keywords {
    return keyword + '_'
  }
  return keyword
}

fn write_enum_member(mut wr strings.Builder, type_name string, member_name string) {
  wr.write_string('${type_name}.${escape_keyword(member_name)}')
}

fn write_enum_array(mut wr strings.Builder, enum_type_name string, list []string) {
	wr.writeln('[')
	for i, keyword in list {
		wr.write_string('   ')

		type_name := if i == 0 { enum_type_name } else { '' }
		write_enum_member(mut wr, type_name, keyword)

		if i < list.len - 1 {
			wr.write_u8(`,`)
		}
		wr.write_u8(`\n`)
	}
	wr.write_u8(`]`)
}

fn write_const_enum_array(mut wr strings.Builder, var_name string, enum_type_name string, list []string) {
  wr.write_string('\nconst ${var_name} = ')
  write_enum_array(mut wr, enum_type_name, list)
  wr.write_u8(`\n`)
}

struct TSNodeType {
  name string @[json: 'type']
  named bool
  subtypes []TSNodeType
}

fn (typ TSNodeType) is_anonymous() bool {
  return !typ.named || typ.name.len == 0 || typ.name[0] == `_`
}

current_dir := dir(@FILE)
node_types_json := read_file(join_path('..', 'vscript-tree-sitter', 'src', 'node-types.json'))!
node_types := json.decode([]TSNodeType, node_types_json)!
node_type_enum_name := 'NodeType'
super_type_enum_name := 'SuperType'
file_path := join_path(current_dir, 'node_types.v')
mut file := open_file(file_path, 'w')!
mut sb := strings.new_builder(1024 * 1024)
mut super_type_node_groups := map[string][]string{}

sb.writeln('// AUTOGENERATED BY @bindings/generate_types.vsh. This file is not intended to be modified.')
sb.writeln('module bindings\n')
sb.writeln('import arrays {merge}')
sb.writeln('pub enum ${node_type_enum_name} {')
sb.writeln('   unknown')
for node_type in node_types {
	if !node_type.named || node_type.name.len == 0 || node_type.name[0] != `_`
		|| node_type.subtypes.len == 0 {
		continue
	}
	sb.writeln('   ${escape_keyword(node_type.name[1..])}')
	super_type_node_groups[node_type.name] = node_type.subtypes.map(it.name)
}
sb.writeln('}\n')
sb.writeln('pub enum ${node_type_enum_name} {')
sb.writeln('  unkown')
sb.writeln('  error')

mut declaration_node_types := []string{cap: 100}
mut identifier_node_types := []string{cap: 100}
mut literal_node_types := []string{cap: 100}

for node_type in node_types {
  if node_type.is_anonymous() {
    continue
  }

  if node_type.name.ends_with('_declaration') {
    declaration_node_types << node_type.name
  } else if node_type.name == 'identifier'|| node_type.name.ends_with('_identifier') {
    identifier_node_types << node_type.name
  } else if node_type.name.ends_with('_literal') {
    literal_node_types << node_type.name
  }

  sb.writeln('  ${escape_keyword(node_type.name)}')
}
sb.writeln('}\n')

for supertype_name, super_type_node_types in super_type_node_groups {
  sb.write_string('\n')
  sb.write_string('const supertype_${supertype_name}_nodes = ')
  super_type_members := super_type_node_types.filter(it.starts_with('_'))
  for type_member in super_type_members {
    sb.write_string('merge(supertype_${type_member}_nodes, ')
  }

  write_enum_array(mut sb, node_type_enum_name, super_type_node_types.filter(!it.starts_with('_')))
  sb.write_string(')'.repeat(super_type_members.len))
}

sb.write_string('\n')
sb.write_string('pub fn (typ ${node_type_enum_name}) group() ${super_type_enum_name} {')

supertype_ordered_names := [
	'top_level_declaration',
	'expression',
	'statement',
	'unknown',
]
mut super_type_index := 0

for supertype_name in supertype_ordered_names {
	if super_type_index < supertype_ordered_names.len - 1 {
		sb.write_string('if typ in supertype__${supertype_name}_nodes ')
	}
	sb.write_string('{\n      ')
	write_enum_member(mut sb, super_type_enum_name, supertype_name)
	sb.write_string('\n   }')
	if super_type_index < supertype_ordered_names.len - 1 {
		sb.write_string(' else ')
	} else {
		sb.write_u8(`\n`)
	}
	super_type_index++
}
sb.writeln('}')

write_const_enum_array(mut sb, 'declaration_node_types', node_type_enum_name, declaration_node_types)
write_const_enum_array(mut sb, 'identifier_node_types', node_type_enum_name, identifier_node_types)
write_const_enum_array(mut sb, 'literal_node_types', node_type_enum_name, literal_node_types)

sb.writeln('\n')
sb.writeln('pub fn (typ ${node_type_enum_name}) is_declaration() bool { return typ in declaration_node_types }')
sb.writeln('pub fn (typ ${node_type_enum_name}) is_identifier() bool { return typ in identifier_node_types }')
sb.writeln('pub fn (typ ${node_type_enum_name}) is_literal() bool { return typ in literal_node_types }')

node_type_factory_sym_name := 'VNodeTypeFactory'

sb.writeln('\n')
sb.writeln('pub const type_factory = &${node_type_factory_sym_name}{}\n')
sb.writeln('pub struct ${node_type_factory_sym_name} {}\n')
sb.writeln('pub fn (nf ${node_type_factory_sym_name}) get_type(type_name string) ${node_type_factory_sym_name} {')
sb.writeln('  return bindings.node_type_name_to_enum[type_name] or { NodeType.unknown }')
sb.writeln('}\n')
sb.writeln('const node_type_name_to_enum = {')
sb.write_string("      'ERROR': ${node_type_enum_name}.error")
for node_type in node_types {
  if node_type.is_anonymous() {
    continue
  }
  sb.write_string("      '${node_type.name}': ")
  write_enum_member(mut sb, node_type_enum_name, node_type.name)
  sb.writeln('')
}
sb.writeln('}')

file.write(sb)!
file.close()

res := os.execute('v fmt -w ${file_path}')
if res.exit_code != 0 {
  panic('v fmt failed:\n\n${res.output}')
}
println('${file_path} generated successfully')
